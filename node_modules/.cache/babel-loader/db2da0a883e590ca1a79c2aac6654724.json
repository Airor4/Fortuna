{"ast":null,"code":"import BoundingBox from './BoundingBox.js';\nimport CasusBlock from './CasusBlock.js';\nimport EmptyBlock from './EmptyBlock.js';\nimport Vec from './Vec.js';\nimport { HIGHLIGHT_STROKE_WIDTH } from './generateCornerPerim.js';\n\nclass ContainerBlock extends CasusBlock {\n  constructor(children = [new EmptyBlock('VOID')]) {\n    super();\n    this.children = children;\n  }\n\n  precompBounds() {\n    //set this.boundingBox\n    let w = 0;\n    let h = 0;\n\n    for (const child of this.getChildBlocks()) {\n      child.precompBounds();\n      w = Math.max(w, child.boundingBox.w);\n      h += child.boundingBox.h;\n    }\n\n    this.boundingBox = new BoundingBox(0, 0, w, h);\n  }\n\n  precompXY(x, y) {\n    this.boundingBox.x = x;\n    this.boundingBox.y = y;\n    let curY = y;\n\n    for (const child of this.getChildBlocks()) {\n      child.precompXY(x, curY);\n      curY += child.boundingBox.h;\n    }\n  }\n\n  getChildBlocks() {\n    return this.children;\n  }\n\n  removeBlockAt(v, removeAfter) {\n    for (let i = 0; i < this.children.length; i++) {\n      const child = this.children[i];\n      const childRes = child.removeBlockAt(v, removeAfter);\n\n      if (childRes.length > 0) {\n        return childRes;\n      }\n\n      if (child.boundingBox.contains(v) && child.draggable()) {\n        const toReturn = removeAfter ? this.children.splice(i) : this.children.splice(i, 1);\n\n        if (this.children.length === 0) {\n          this.children.push(new EmptyBlock('VOID'));\n        }\n\n        return toReturn;\n      }\n    }\n\n    return [];\n  }\n\n  draggable() {\n    return false;\n  }\n\n  getPerim() {\n    return [];\n  }\n\n  drawSelf(ctx) {}\n\n  getReturnType() {\n    return 'VOID';\n  }\n\n  tryToPlace(v, blockToPlace, ctx) {\n    if (!this.boundingBox.contains(v)) {\n      return null;\n    }\n\n    for (let i = 0; i < this.children.length; i++) {\n      var _this$children$i$tryT;\n\n      this.children[i] = (_this$children$i$tryT = this.children[i].tryToPlace(v, blockToPlace, ctx)) !== null && _this$children$i$tryT !== void 0 ? _this$children$i$tryT : this.children[i];\n    } //If I only had one child that was an empty block and I just replaced him with another\n    //container block, then I should just comendeer the container block's children\n\n\n    for (let i = 0; i < this.children.length; i++) {\n      if (this.children[i] instanceof ContainerBlock) {\n        this.children.splice(i, 1, ...this.children[i].children);\n      }\n    }\n  }\n\n  tryToPlaceInContainer(v, blockToPlace, ctx) {\n    if (!this.boundingBox.contains(v)) {\n      return false;\n    } //if I can place it in any of my children, don't worry about it here\n\n\n    for (const child of this.getChildBlocks()) {\n      if (child.tryToPlaceInContainer(v, blockToPlace, ctx)) {\n        return true;\n      }\n    } //otherwise, we are going to place it here, so we need to find the closest y\n\n\n    let bestIndex = 0;\n    let bestError = Math.abs(this.boundingBox.y - v.y);\n    let bestY = this.boundingBox.y;\n\n    for (let potentialIndex = 1; potentialIndex <= this.children.length; potentialIndex++) {\n      const child = this.children[potentialIndex - 1];\n      const curY = child.boundingBox.y + child.boundingBox.h;\n      const curError = Math.abs(curY - v.y);\n\n      if (curError < bestError) {\n        bestError = curError;\n        bestIndex = potentialIndex;\n        bestY = curY;\n      }\n    }\n\n    if (ctx == null) {\n      //then actually place it\n      if (blockToPlace instanceof ContainerBlock) {\n        const toPlace = blockToPlace.children;\n        this.children.splice(bestIndex, 0, ...toPlace);\n      } else {\n        this.children.splice(bestIndex, 0, blockToPlace);\n      }\n    } else {\n      //otherwise just draw the highlight\n      ctx.beginPath();\n      ctx.strokeStyle = '#eeeeee';\n      ctx.lineWidth = HIGHLIGHT_STROKE_WIDTH;\n      ctx.moveTo(this.boundingBox.x, bestY);\n      ctx.lineTo(this.boundingBox.x + this.boundingBox.w, bestY);\n      ctx.closePath();\n      ctx.stroke();\n    }\n\n    return true;\n  }\n\n}\n\nexport default ContainerBlock;","map":{"version":3,"sources":["/Users/Airor/Desktop/Fortuna/Fortuna/fortuna/src/casus/blocks/ContainerBlock.js"],"names":["BoundingBox","CasusBlock","EmptyBlock","Vec","HIGHLIGHT_STROKE_WIDTH","ContainerBlock","constructor","children","precompBounds","w","h","child","getChildBlocks","Math","max","boundingBox","precompXY","x","y","curY","removeBlockAt","v","removeAfter","i","length","childRes","contains","draggable","toReturn","splice","push","getPerim","drawSelf","ctx","getReturnType","tryToPlace","blockToPlace","tryToPlaceInContainer","bestIndex","bestError","abs","bestY","potentialIndex","curError","toPlace","beginPath","strokeStyle","lineWidth","moveTo","lineTo","closePath","stroke"],"mappings":"AAEA,OAAOA,WAAP,MAAwB,kBAAxB;AACA,OAAOC,UAAP,MAAuB,iBAAvB;AACA,OAAOC,UAAP,MAAuB,iBAAvB;AACA,OAAOC,GAAP,MAAgB,UAAhB;AACA,SAAQC,sBAAR,QAAqC,0BAArC;;AAIA,MAAMC,cAAN,SAA6BJ,UAA7B,CAAwC;AAIvCK,EAAAA,WAAW,CAACC,QAA2B,GAAG,CAAC,IAAIL,UAAJ,CAAe,MAAf,CAAD,CAA/B,EAAyD;AACnE;AACA,SAAKK,QAAL,GAAcA,QAAd;AACA;;AAEDC,EAAAA,aAAa,GAAS;AACrB;AACA,QAAIC,CAAQ,GAAG,CAAf;AACA,QAAIC,CAAQ,GAAG,CAAf;;AACA,SAAK,MAAMC,KAAX,IAAoB,KAAKC,cAAL,EAApB,EAA2C;AAC1CD,MAAAA,KAAK,CAACH,aAAN;AACAC,MAAAA,CAAC,GAACI,IAAI,CAACC,GAAL,CAASL,CAAT,EAAYE,KAAK,CAACI,WAAN,CAAkBN,CAA9B,CAAF;AACAC,MAAAA,CAAC,IAAEC,KAAK,CAACI,WAAN,CAAkBL,CAArB;AACA;;AACD,SAAKK,WAAL,GAAiB,IAAIf,WAAJ,CAAgB,CAAhB,EAAmB,CAAnB,EAAsBS,CAAtB,EAAyBC,CAAzB,CAAjB;AACA;;AAEDM,EAAAA,SAAS,CAACC,CAAD,EAAYC,CAAZ,EAA4B;AACpC,SAAKH,WAAL,CAAiBE,CAAjB,GAAqBA,CAArB;AACA,SAAKF,WAAL,CAAiBG,CAAjB,GAAqBA,CAArB;AACA,QAAIC,IAAY,GAAGD,CAAnB;;AAEA,SAAK,MAAMP,KAAX,IAAoB,KAAKC,cAAL,EAApB,EAA2C;AAC1CD,MAAAA,KAAK,CAACK,SAAN,CAAgBC,CAAhB,EAAmBE,IAAnB;AACAA,MAAAA,IAAI,IAAER,KAAK,CAACI,WAAN,CAAkBL,CAAxB;AACA;AACD;;AAEDE,EAAAA,cAAc,GAAsB;AACnC,WAAO,KAAKL,QAAZ;AACA;;AAEDa,EAAAA,aAAa,CAACC,CAAD,EAASC,WAAT,EAAkD;AAC9D,SAAK,IAAIC,CAAC,GAAC,CAAX,EAAcA,CAAC,GAAC,KAAKhB,QAAL,CAAciB,MAA9B,EAAsCD,CAAC,EAAvC,EAA2C;AAC1C,YAAMZ,KAAiB,GAAG,KAAKJ,QAAL,CAAcgB,CAAd,CAA1B;AACA,YAAME,QAAQ,GAAGd,KAAK,CAACS,aAAN,CAAoBC,CAApB,EAAuBC,WAAvB,CAAjB;;AACA,UAAIG,QAAQ,CAACD,MAAT,GAAkB,CAAtB,EAAyB;AACxB,eAAOC,QAAP;AACA;;AACD,UAAId,KAAK,CAACI,WAAN,CAAkBW,QAAlB,CAA2BL,CAA3B,KAAiCV,KAAK,CAACgB,SAAN,EAArC,EAAwD;AACvD,cAAMC,QAAQ,GAACN,WAAW,GAAE,KAAKf,QAAL,CAAcsB,MAAd,CAAqBN,CAArB,CAAF,GAA4B,KAAKhB,QAAL,CAAcsB,MAAd,CAAqBN,CAArB,EAAwB,CAAxB,CAAtD;;AACA,YAAI,KAAKhB,QAAL,CAAciB,MAAd,KAAyB,CAA7B,EAAgC;AAC/B,eAAKjB,QAAL,CAAcuB,IAAd,CAAmB,IAAI5B,UAAJ,CAAe,MAAf,CAAnB;AACA;;AACD,eAAO0B,QAAP;AACA;AACD;;AAED,WAAO,EAAP;AACA;;AAEDD,EAAAA,SAAS,GAAY;AACpB,WAAO,KAAP;AACA;;AAEDI,EAAAA,QAAQ,GAAe;AACtB,WAAO,EAAP;AACA;;AAEDC,EAAAA,QAAQ,CAACC,GAAD,EAAsC,CAC7C;;AAEDC,EAAAA,aAAa,GAAa;AACzB,WAAO,MAAP;AACA;;AAEDC,EAAAA,UAAU,CAACd,CAAD,EAASe,YAAT,EAAmCH,GAAnC,EAAgF;AACzF,QAAI,CAAC,KAAKlB,WAAL,CAAiBW,QAAjB,CAA0BL,CAA1B,CAAL,EAAmC;AAClC,aAAO,IAAP;AACA;;AACD,SAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAC,KAAKhB,QAAL,CAAciB,MAAhC,EAAwCD,CAAC,EAAzC,EAA6C;AAAA;;AAC5C,WAAKhB,QAAL,CAAcgB,CAAd,6BAAmB,KAAKhB,QAAL,CAAcgB,CAAd,EAAiBY,UAAjB,CAA4Bd,CAA5B,EAA+Be,YAA/B,EAA6CH,GAA7C,CAAnB,yEAAwE,KAAK1B,QAAL,CAAcgB,CAAd,CAAxE;AACA,KANwF,CAOzF;AACA;;;AACA,SAAK,IAAIA,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAC,KAAKhB,QAAL,CAAciB,MAAhC,EAAwCD,CAAC,EAAzC,EAA6C;AAC5C,UAAI,KAAKhB,QAAL,CAAcgB,CAAd,aAA4BlB,cAAhC,EAAgD;AAC/C,aAAKE,QAAL,CAAcsB,MAAd,CAAqBN,CAArB,EAAwB,CAAxB,EAA2B,GAAG,KAAKhB,QAAL,CAAcgB,CAAd,EAAiBhB,QAA/C;AACA;AACD;AACD;;AAED8B,EAAAA,qBAAqB,CAAChB,CAAD,EAASe,YAAT,EAAmCH,GAAnC,EAA4E;AAChG,QAAI,CAAC,KAAKlB,WAAL,CAAiBW,QAAjB,CAA0BL,CAA1B,CAAL,EAAmC;AAClC,aAAO,KAAP;AACA,KAH+F,CAIhG;;;AACA,SAAK,MAAMV,KAAX,IAAoB,KAAKC,cAAL,EAApB,EAA2C;AAC1C,UAAID,KAAK,CAAC0B,qBAAN,CAA4BhB,CAA5B,EAA+Be,YAA/B,EAA6CH,GAA7C,CAAJ,EAAuD;AACtD,eAAO,IAAP;AACA;AACD,KAT+F,CAWhG;;;AACA,QAAIK,SAAS,GAAG,CAAhB;AACA,QAAIC,SAAS,GAAG1B,IAAI,CAAC2B,GAAL,CAAS,KAAKzB,WAAL,CAAiBG,CAAjB,GAAqBG,CAAC,CAACH,CAAhC,CAAhB;AACA,QAAIuB,KAAK,GAAG,KAAK1B,WAAL,CAAiBG,CAA7B;;AACA,SAAK,IAAIwB,cAAc,GAAC,CAAxB,EAA2BA,cAAc,IAAE,KAAKnC,QAAL,CAAciB,MAAzD,EAAiEkB,cAAc,EAA/E,EAAmF;AAClF,YAAM/B,KAAK,GAAG,KAAKJ,QAAL,CAAcmC,cAAc,GAAC,CAA7B,CAAd;AACA,YAAMvB,IAAI,GAAGR,KAAK,CAACI,WAAN,CAAkBG,CAAlB,GAAsBP,KAAK,CAACI,WAAN,CAAkBL,CAArD;AACA,YAAMiC,QAAQ,GAAG9B,IAAI,CAAC2B,GAAL,CAASrB,IAAI,GAAGE,CAAC,CAACH,CAAlB,CAAjB;;AACA,UAAIyB,QAAQ,GAAGJ,SAAf,EAA0B;AACzBA,QAAAA,SAAS,GAAGI,QAAZ;AACAL,QAAAA,SAAS,GAACI,cAAV;AACAD,QAAAA,KAAK,GAAGtB,IAAR;AACA;AACD;;AACD,QAAIc,GAAG,IAAI,IAAX,EAAiB;AAChB;AACA,UAAIG,YAAY,YAAY/B,cAA5B,EAA4C;AAC3C,cAAMuC,OAAO,GAAER,YAAD,CAA+B7B,QAA7C;AACA,aAAKA,QAAL,CAAcsB,MAAd,CAAqBS,SAArB,EAAgC,CAAhC,EAAmC,GAAGM,OAAtC;AACA,OAHD,MAIK;AACJ,aAAKrC,QAAL,CAAcsB,MAAd,CAAqBS,SAArB,EAAgC,CAAhC,EAAmCF,YAAnC;AACA;AACD,KATD,MAUK;AACJ;AACAH,MAAAA,GAAG,CAACY,SAAJ;AACAZ,MAAAA,GAAG,CAACa,WAAJ,GAAkB,SAAlB;AACAb,MAAAA,GAAG,CAACc,SAAJ,GAAgB3C,sBAAhB;AACA6B,MAAAA,GAAG,CAACe,MAAJ,CAAW,KAAKjC,WAAL,CAAiBE,CAA5B,EAA+BwB,KAA/B;AACAR,MAAAA,GAAG,CAACgB,MAAJ,CAAW,KAAKlC,WAAL,CAAiBE,CAAjB,GAAqB,KAAKF,WAAL,CAAiBN,CAAjD,EAAoDgC,KAApD;AACAR,MAAAA,GAAG,CAACiB,SAAJ;AACAjB,MAAAA,GAAG,CAACkB,MAAJ;AACA;;AACD,WAAO,IAAP;AACA;;AApIsC;;AAwIxC,eAAe9C,cAAf","sourcesContent":["//@flow strict\n\nimport BoundingBox from './BoundingBox.js';\nimport CasusBlock from './CasusBlock.js';\nimport EmptyBlock from './EmptyBlock.js';\nimport Vec from './Vec.js'\nimport {HIGHLIGHT_STROKE_WIDTH} from './generateCornerPerim.js';\n\nimport type {DataType} from './DataType.js';\n\nclass ContainerBlock extends CasusBlock {\n\n\tchildren: Array<CasusBlock>;\n\n\tconstructor(children: Array<CasusBlock> = [new EmptyBlock('VOID')]) {\n\t\tsuper();\n\t\tthis.children=children;\n\t}\n\n\tprecompBounds(): void {\n\t\t//set this.boundingBox\n\t\tlet w:number = 0;\n\t\tlet h:number = 0;\n\t\tfor (const child of this.getChildBlocks()) {\n\t\t\tchild.precompBounds();\n\t\t\tw=Math.max(w, child.boundingBox.w);\n\t\t\th+=child.boundingBox.h;\n\t\t}\n\t\tthis.boundingBox=new BoundingBox(0, 0, w, h);\n\t}\n\n\tprecompXY(x: number, y:number): void {\n\t\tthis.boundingBox.x = x;\n\t\tthis.boundingBox.y = y;\n\t\tlet curY: number = y;\n\n\t\tfor (const child of this.getChildBlocks()) {\n\t\t\tchild.precompXY(x, curY);\n\t\t\tcurY+=child.boundingBox.h;\n\t\t}\n\t}\n\n\tgetChildBlocks(): Array<CasusBlock> {\n\t\treturn this.children;\n\t}\n\n\tremoveBlockAt(v: Vec, removeAfter: boolean): Array<CasusBlock> {\n\t\tfor (let i=0; i<this.children.length; i++) {\n\t\t\tconst child: CasusBlock = this.children[i];\n\t\t\tconst childRes = child.removeBlockAt(v, removeAfter);\n\t\t\tif (childRes.length > 0) {\n\t\t\t\treturn childRes;\n\t\t\t}\n\t\t\tif (child.boundingBox.contains(v) && child.draggable()) {\n\t\t\t\tconst toReturn=removeAfter? this.children.splice(i) : this.children.splice(i, 1);\n\t\t\t\tif (this.children.length === 0) {\n\t\t\t\t\tthis.children.push(new EmptyBlock('VOID'));\n\t\t\t\t}\n\t\t\t\treturn toReturn;\n\t\t\t}\n\t\t}\n\n\t\treturn [];\n\t}\n\n\tdraggable(): boolean {\n\t\treturn false;\n\t}\n\n\tgetPerim(): Array<Vec> {\n\t\treturn [];\n\t}\n\n\tdrawSelf(ctx: CanvasRenderingContext2D): void {\n\t}\n\n\tgetReturnType(): DataType {\n\t\treturn 'VOID';\n\t}\n\n\ttryToPlace(v: Vec, blockToPlace: CasusBlock, ctx: ?CanvasRenderingContext2D): ?CasusBlock {\n\t\tif (!this.boundingBox.contains(v)) {\n\t\t\treturn null;\n\t\t}\n\t\tfor (let i = 0; i<this.children.length; i++) {\n\t\t\tthis.children[i] = this.children[i].tryToPlace(v, blockToPlace, ctx) ?? this.children[i];\n\t\t}\n\t\t//If I only had one child that was an empty block and I just replaced him with another\n\t\t//container block, then I should just comendeer the container block's children\n\t\tfor (let i = 0; i<this.children.length; i++) {\n\t\t\tif (this.children[i] instanceof ContainerBlock) {\n\t\t\t\tthis.children.splice(i, 1, ...this.children[i].children);\n\t\t\t}\n\t\t}\n\t}\n\n\ttryToPlaceInContainer(v: Vec, blockToPlace: CasusBlock, ctx: ?CanvasRenderingContext2D): boolean {\n\t\tif (!this.boundingBox.contains(v)) {\n\t\t\treturn false;\n\t\t}\n\t\t//if I can place it in any of my children, don't worry about it here\n\t\tfor (const child of this.getChildBlocks()) {\n\t\t\tif (child.tryToPlaceInContainer(v, blockToPlace, ctx)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//otherwise, we are going to place it here, so we need to find the closest y\n\t\tlet bestIndex = 0;\n\t\tlet bestError = Math.abs(this.boundingBox.y - v.y);\n\t\tlet bestY = this.boundingBox.y;\n\t\tfor (let potentialIndex=1; potentialIndex<=this.children.length; potentialIndex++) {\n\t\t\tconst child = this.children[potentialIndex-1];\n\t\t\tconst curY = child.boundingBox.y + child.boundingBox.h;\n\t\t\tconst curError = Math.abs(curY - v.y);\n\t\t\tif (curError < bestError) {\n\t\t\t\tbestError = curError;\n\t\t\t\tbestIndex=potentialIndex;\n\t\t\t\tbestY = curY;\n\t\t\t}\n\t\t}\n\t\tif (ctx == null) {\n\t\t\t//then actually place it\n\t\t\tif (blockToPlace instanceof ContainerBlock) {\n\t\t\t\tconst toPlace=(blockToPlace: ContainerBlock).children;\n\t\t\t\tthis.children.splice(bestIndex, 0, ...toPlace);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.children.splice(bestIndex, 0, blockToPlace);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t//otherwise just draw the highlight\n\t\t\tctx.beginPath();\n\t\t\tctx.strokeStyle = '#eeeeee';\n\t\t\tctx.lineWidth = HIGHLIGHT_STROKE_WIDTH;\n\t\t\tctx.moveTo(this.boundingBox.x, bestY);\n\t\t\tctx.lineTo(this.boundingBox.x + this.boundingBox.w, bestY);\n\t\t\tctx.closePath();\n\t\t\tctx.stroke();\n\t\t}\n\t\treturn true;\n\t}\n\n}\n\nexport default ContainerBlock;\n"]},"metadata":{},"sourceType":"module"}